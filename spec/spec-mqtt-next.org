#+title: Spec Mqtt Next

* Abstract

This document defines MQTT-next, a mapping of MQTT to the QUIC transport protocol.

* Definitions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 RFC2119 RFC8174 when, and only when, they appear in all capitals, as shown here.

endpoint: MQTT client or MQTT broker
 
connection: A transport-layer connection between two endpoints using QUIC as the transport protocol, defined in RFC9000

stream: QUIC stream defined in RFC9000

session: MQTT session defined in MQTT spec

bidi: stream direction, bidirectional

unidi: stream direction, unidirectional

local stream: stream which is initiated locally

remote stream: stream which is initiated by remote endpoint.

flow: stream abstraction in MQTT layer, part of MQTT session.

flow owner: the endpoint who initiates the stream thus owns it.

client flow: flow initiated by the client and client owns it.

server flow: flow initiated by the server and server owns it.

datagram: QUIC unreliable datagram

sender: endpoint which can send data over a flow

receiver: endpoint which can receive data over a flow

MQTT packet(s): MQTT control packets defined in MQTT protocol.

HOLB: head-of-line blocking

peer: remote endpoint

mqtt-next: unversioned MQTT version that supports MQTT over QUIC advance multistream mode.

ttl: time to live

* Notational Conventions

Conforms to 1.3 of the notational conventions of RFC 9000


* Motivation

QUIC is the transport layer of HTTP/3, standardised by IETF.

MQTT could leveraging QUIC's powerful features promises to significantly enhance MQTT's flexibility and performance,
particularly in the context of modern mobile networks and demanding applications.

** Performance Enhancements

Faster connections: QUIC's single round-trip connection establishment significantly reduces latency, especially for clients on high-latency networks.

Rapid reconnection and early data sending: QUIC's 0-RTT resumption allows for near-instantaneous reconnection after disconnections, while early data sends eliminate waiting for server responses.

** Network address migration

QUIC seamlessly adapts to network changes, ensuring MQTT clients remain connected and minimizing offline periods.

** Reliable Delivery in Unreliable Networks

QUIC is specifically designed to operate effectively in networks with packet loss and reordering.
This is crucial for MQTT-next in mobile network scenarios where such network conditions are common.

** Multiplexing enables flexible asynchronous parallel streaming

Stream runs independently, single stream provides ordering and multistream provides concurrency.

- Dynamic flow control and prioritization

  Application data is managed effectively with precise flow control and prioritization features.

- Coexistence with other public/private protocols such as http/3.

- Packet send/recv cancellation.

  Large payload message in transmission could be cancelled by either receiver or sender.

- Make MQTT more resilient to application errors.

- Mitigate HOLB

  Head-of-Line Blocking (HOLB) only affects specific QUIC streams, not the entire connection, minimizing its overall impact.

** Flexiable message delivery

Delivery Options: QUIC offers a spectrum of delivery options, including ordered/unordered and reliable/unreliable, catering to diverse application requirements.

** Embedded security

- Default TLS 1.3:

  QUIC utilizes the latest TLS 1.3 by default, offering strong encryption, perfect forward secrecy, and improved performance compared to older versions.

- Post-Quantum Cryptography (PQC) Readiness

  QUIC is designed to readily integrate PQC algorithms when they become standardized, ensuring long-term cryptographic agility against potential quantum computing threats.

- Key Update Mechanisms:

  QUIC employs robust key update mechanisms, including forward secrecy and session resumption, to mitigate replay attacks and maintain security even after key compromises.

- Integrity and Authentication:

  QUIC employs authenticated encryption, ensuring both data integrity and sender authentication, preventing unauthorized message modifications and impersonation.

- Cryptographic Integrity:

  Even in the presence of packet loss or reordering, QUIC's cryptographic mechanisms ensure message integrity and authenticity.
  This prevents unauthorized data modifications and protects against potential security exploits.

- Denial-of-Service (DoS) Protection:

  QUIC incorporates several features to mitigate DoS attacks, such as connection limits, packet pacing, and handshake throttling.


** Pluggable security suite and congestion control

Always ready for future updates without requiring major changes to the network.

Congestion control can be tailored to the needs of the application.

* New features in MQTT-next

- Fast security handshake with 1 RTT and 0 RTT

  Secure connection handshake could be done in 0 or 1 roundtrip time.

- Connection could survive network changes.

  QUIC's address migration makes MQTT more robust to network changes, reducing the chance of disconnection.

- Elimination of HOL blocking.

  In TCP-based transport, the MQTT packet at the head of the line blocks all subsequent messages following it, it also
  blocks the MQTT.PING/MQTT.PINGREQ for keepalive.
  Long blocking of keepalive could cause disconnection at other endpoint.

  With QUIC, QUIC knows the importance of each message and sends them in separate channels that won't block each other.
  
- Separate control and data traffic.

  With TCP-based transport, a MQTT.PUBLISH message with a large payload can block the entire TCP stream and MQTT.PINGREQ/MQTT.PINGRESP.
  With QUIC, the PUB message and the PINGREQ could be sent in different streams.
  
    PINGREQ, which is used for keep-alive or liveness detection at the MQTT layer, must be sent on a higher priority control flow.
    
- Classified application data

  QUIC multi-streams allows the application to send different application data on different streams.

  For example

  1. assign different topic data to different streams

  2. Separate stream for different QoS messages.

  3. Separate stream for publishing and subscriptions.

- Flow control on classified traffic

  QUIC enables flow control both at the connection level and at the stream level.

  This allows application data relays on different QUIC streams to be flow controlled independently.

- Prioritised traffic

  QUIC enables MQTT to prioritise traffic from different streams.

  This affects loss recovery behaviour and network congestion.

- Enhanced security

- Coexistence with other applications on the same connection such as HTTP/3

  QUIC Multiplexing allows the MQTT protocol to coexist with other public/private protocols on the same connection.

- MQTT packet(s) transmission could be cancelled.

  QUIC makes it possible to abort a MQTT packet on both the sender and receiver side without affecting the connectivity.

  For cases like

  - Cancel the transmission of a large payload packet.
  - Cancel the transmission of obsolete packets.

  For TCP-based traffic, cancelling a pending MQTT packet means disconnecting and reconnecting.

- Support both reliable and unreliable delivery.

  RFC9221 extended the QUIC protocol to support unreliable delivery.

  This could make MQTT QoS 0 packets truly "fire and forget" with almost no cost for retransmission.

  In TCP-based protocol, the TCP segment containing the bytes of the QoS 0 packet is retransmitted by the TCP stack in order.

- Build-in transport layer keepalive

  In MQTT-next, both client and server could use the keep-alive mechanism of QUIC transport, which is end-to-end.

  This simplifies the implementation at the MQTT client and server in terms of timing.

  And it is end to end, meaning that the keepalive message must be delivered to the peer without worrying about being terminated
  through a middleman such as a proxy, NAT gateway or LB.

- Failure isolation.

  The client and the broker can agree how to handle a failure per flow. To minimise the side effect of the failure.

  A single messaging failure such as a malformed packet MUST cause the flow to be aborted, but it MAY or MAY NOT cause the connection to be closed.

- Variable header compression [TBD]

  MQTT packets are binary coded packets, it is designed for smaller packet size. In order to reduce packet size without losing information,
  topic alias could be used to avoid retransmitting whole long topic in each packet. But that is not all for the other headers, such as the Content Type header.

  HTTP/3 Q-PACK enables header compression/encoding, which the MQTT protocol could use to reduce packet size by compressing other variable headers,
  variable headers or user-defined properties.


* Overview of changes/extensions to the MQTT protocol

1. MQTT packets are transported via reliable flow or unreliable datagrams.
2. The subscription is now associated with the flow.
3. Acking QoS > 0 messages is also done on the same flow that it is published.
4. Publish QoS 0 messages MAY have the Packet ID field as they could be sent in datagrams.
   Application at receive side MAY use Packet ID to identify if the packet is a resend or check the ordering of
   unordered messages.
5. Flow state per flow is introduced to track the QoS > 0 message delivery.
6. MQTT packet flow control is now in the flow scope instead of in the connection scope.
   The flow header could have optional "Receive maximum" header.
7. The server can 'push' messages to the server flow, which the server initiates.
8. PINGREQ/PINGRESP are associated with the flow for application liveness detection, and the keep-alive interval is not enforced on the data stream.     

* Operating Modes

A QUIC connection is REQUIRED between the client and the server as defined in RFC 9000.

The MQTT packets are transported over the flows, which are the QUIC streams.

A QUIC stream provides reliable in-order delivery of bytes, but makes no
guarantees about the order of delivery of bytes on other
streams.

QUIC streams can be either unidirectional, carrying data only from the
initiator to receiver, or bidirectional, carrying data in both directions.
directions.  Streams in the connection can be initiated by either endpoint,
the client or the server.

There are three modes of operation for QUIC-next, each mode having its own advantages and disadvantages in terms of

- Compatibility with MQTT protocols

- Supported features


** Single Stream

The simplist mode simply replaces the TCP based transport with a QUIC stream in the QUIC connection.

A BIDI stream is initiated from the client after the connection handshake and is used to carry all MQTT
to carry all MQTT control packets. It is compatible with MQTT 3.1 and MQTT 5.0 and nothing in the MQTT packet is
changed in the MQTT packet.

Pros: Easy to implement, NO changes in MQTT layer. Benefits from QUIC connection.

Cons: For complex applications that have multiple topics and/or different QoS,
      Does not take full advantage of QUIC transport features.

** Simple multistreams

Enhanced single stream mode with support for multistreams, i.e. one control stream and one or more data streams.

Application data and QUIC stream mapping is controlled by the client.

Compatible with single stream mode.

      Advantages:

      a. Support for multiple streams.
      b. Mitigate HOLB application side.
      c. Enable parallel processing at both endpoints.
      d. Sender defines priority.
      e. Freedom in application data and stream mapping

      Disadvantages:
      a. Persistent stream session is not available on data stream.
         In this mode there is no stream header, the stream only streams MQTT packets, client and server could not.

** Advanced multistreams

Extends the simple multistream mode with the following features:

1. Can coexist with another protocol (http/3 or private protocol) on the same connection.
2. Support unreliable delivery.
3. Defines control message cancellation procedure.
4. Server initiated stream for predefined subscriptions.
5. Abstract 'flow' concept that could be resumed after reconnect.
6. Q-PACK support for message header compression, greatly reducing message size.
7. Defines robustness flow procedure.
8. Defines protocol discovery and upgrade/downgrade procedure.

Advantages:

- MQTT 5.0 feature complete
- Flexible packet delivery reliable/unreliable, ordered, out-of-order, send/recv aborts.
- Flexible control stream discovery
- Flexible connection management.

Disadvantages:

- Extends MQTT 5.0 session data, requires changes to MQTT session layer
- Fallback to TCP/TLS becomes a completely different protocol.

** Work mode feature summary

|------------------------------+---------------+--------------------+----------------------+-------|
| Mode                         | Single Stream | Simple Multstreams | Advanced Multstreams | notes |
|------------------------------+---------------+--------------------+----------------------+-------|
| MQTT 3.1                     | Y             | Y                  | N                    |       |
| MQTT 5.0                     | Y             | Y (Partly)         | N                    |       |
| MQTT-next                    | N             | N                  | Y                    |       |
| TLS alpn                     | mqtt          | mqtt               | mqtt-next            |       |
|------------------------------+---------------+--------------------+----------------------+-------|
| Connection features          |               |                    |                      |       |
|------------------------------+---------------+--------------------+----------------------+-------|
| Transport Keepalive          | Y             | Y                  | Y                    |       |
| 1 RTT / 0 RTT                | Y             | Y                  | Y                    |       |
| Address migration            | Y             | Y                  | Y                    |       |
| Unreliable Delivery          | N             | N                  | Y                    |       |
| Co-exist with other protocol | N             | N                  | Y                    |       |
|------------------------------+---------------+--------------------+----------------------+-------|
| Streams                      |               |                    |                      |       |
|------------------------------+---------------+--------------------+----------------------+-------|
| Number of Streams (Note 1.)  | 1             | 1..n (Note 2.)     | 1..n                 |       |
| Number of Control Streams    | 1             | 1                  | 1                    |       |
| Number of Data Streams       | 0             | 0..n (Note 2.)     | 0..n                 |       |
| Broker initiated Stream      | N             | N                  | Y                    |       |
| Stream flow control          | N             | Y                  | Y                    |       |
| Stream prioritizion          | N             | Y (Note 3.)        | Y                    |       |
| Unidirectional stream        | N             | N                  | Y                    | TBD   |
|------------------------------+---------------+--------------------+----------------------+-------|
| Persistent sessions          | Y             | P (Note 4.)        | Y                    |       |
| Mitigate HOLB                | N             | Y                  | Y                    |       |
| Send/Recv abortion           | N             | Y                  | Y                    |       |
| Trackable Flows              | N             | N                  | Y                    |       |
|------------------------------+---------------+--------------------+----------------------+-------|

Notes:

1. Number of concurrent streams

2. `n` defined by broker, suggested maximum 64k

3. Client set prioritizion.

4. On control stream only


* Connections

** Establishing a connection

QUIC connections are established as described in [RFC9000].

0-RTT support is optional

** Connection Keepalive

Connection keepalive SHOULD be performed on the QUIC transport. Both server and client maintain keepalive traffic on their own.

However, MQTT keepalive could still be used over QUIC, but note that if QUIC connection keepalive is set,
the connection idle timeout SHOULD be greater than the MQTT keepalive interval to prevent connection idle
shutdown while sending the MQTT.PINGREQ.

** Connection termination

*** Graceful shutdown

Graceful shutdown only requires graceful shutdown of the control flow, other types of flows could be shut down gracefully or aborted. See flow shutdown section.

Connection graceful shutdown could be used for

Broker:
1. redirect the client to the new server
2. prevent MQTT WILL message from being sent.

Client:
1. clear session states
2. set a new session expiration time.

There is no graceful shutdown defined by the QUIC protocol.

In mqtt-next, if either endpoint wishes to gracefully disconnect, it MUST send MQTT.DISCONNECT via the control stream,

it MUST send MQTT.DISCONNECT over the control stream with a reason code explicitly set in the Disconnect Reason Code.
Then it MUST terminate the control flow.

Any MQTT packets received before the control stream is closed SHOULD be properly handled.

After closing the control stream, an endpoint MUST shutdown the connection. Either explicitly (informing the peer) or silently (without informing the peer).

MQTT defines graceful shutdown with the stream shutdown reason code: NO_ERROR.

If MQTT coexists with http/3, the http3/ graceful shutdown procedure must also be followed.

***** Graceful shutdown initiated by the client:

Client MUST first send MQTT.DISCONNECT over control flow
    AND then MUST wait for control flow graceful shutdown to complete
    AND then Client MAY shutdown the connection by starting the connection Immediate shutdown of the QUIC protocol
             OR the client MAY terminate the connection locally without notifying the peer.

Client MUST discard all MQTT packets received from the Broker after sending the MQTT.DISCONNECT.

If the client receives a QUIC CONNECTION_SHUTDOWN FRAME before completing the control flow graceful shutdown procedure
then the graceful shutdown procedure will fail.

Client MAY timeout waiting for a control flow graceful shutdown to complete, it MAY start an immediate connection shutdown procedure with code ERROR_DISCONNECT_TIMEOUT.
Then the Connection graceful shutdown is failed.

If the server receives MQTT.DISCONNECT via control flow,
it MAY attempt to gracefully shut down other flows by processing all received MQTT packets
     AND if MQTT coexists with other protocols, it MUST wait for the other protocol to gracefully shutdown.
     AND server MUST initiate control flow graceful shutdown.
     AND server SHALL not send MQTT messages on any flows.
     AND server MAY initiate the QUIC protocol's immediate disconnect procedure OR silently disconnect locally without notifying the peer.

***** Graceful shutdown triggered by the server:

Server MUST first send MQTT.DISCONNECT via control flow
   AND then MUST wait for the control flow graceful shutdown to complete
   AND server MAY initiate the QUIC protocol's immediate connection termination procedure OR silently terminate the connection locally without notifying the peer.


*** Abnormal connection shutdown

Abnormal connecion shutdown is the shutdown of a connection that is not graceful.

Abnormal connecion shutdown does not require peers to cooperate.

The following conditions can trigger abnormal connection shutdown.

- Aborted control flow shutdown

- Immediate connection shutdown triggered locally by the application.

- Immediate shutdown triggered remotely without completing the control flow Graceful shutdown

- Idle connection.

- Other unrecoverable transport errors such as device failure, OS failure, unhandled network changes.


*** Sending unreliable datagrams over the connection

The QUIC extension RFC 9221 adds support for sending and receiving unreliable datagrams over QUIC.

Support or not support of unreliable datagram is negotiated during connection handshake as defined in RFC [@TODO].

MQTT packet can be encoded in the payload of unreliable datagram.

Unreliable means:

1. Out-of-order delivery of datagram frames.

2. Datagram frame could be lost without recovery.

3. Sending could fail due to size limitation (MTU).

All QoS >= 0 messages could be sent with unreliable datagram.

The unreliable datagram is ACK-eliciting, the application MAY know if the datagram is received or lost.
received, lost or possibly lost, and the application may choose to explicitly resend the
QUIC packet with/without DUP flag based on QoS levels.

Sending unreliable datagram may fail due to reasons, application may try to switch to other communication channels such as using a flow.

Possible known reasons for failure to send unreliable datagram in alive connection.

1. not supported by peer
2. flow control
3. limited by MTU size

The application is free to choose how to encode the message in the datagram.

mqtt-next defines three types of datagram payloads

1. Non-MQTT control packet datagram

   First byte must be 0x00 to distinguish from MQTT packet

2. MQTT control packets

3. Zero length datagram

   The use of zero length datagram should be allowed.

   The application could handle or ignore the UD with payload of 0 length.

   The function of the zero length datagram is implementation specific.

*** Connection downgrade

If the QUIC handshake fails or timed out, the client MUST downgrade the protocol to reconnect to the TCP/TLS endpoint.

The client MUST NOT downgrade from QUIC to plain-text TCP.

*** Discovering and upgrading

The client could learn that the server supports MQTT-next via ALPN during the TCP/TLS handshake, so the upgrade is possible
via QUIC connection to the same endpoint and port before the client sends the MQTT.connect control message over TCP/TLS.

NOTE, When the client transmits the MQTT.connect packet to the server using both TCP-based transport and QUIC transport,
precedence is given to the latter connection established, the latter connection will take over the session.


* MQTT Flows

MQTT Flow provides reliable, ordered unidi/bidi transport for MQTT packets.

There may be one or more flows in a connection between two endpoints.

The flow header identifies the type of flow.

The term =flow= is used to distinguish the term =stream= in the QUIC protocol.

Flows are the abstraction of concurrent logical streams in a multistream advanced mode connection.

Application operates flows:

- start the flow
- close the flow gracefully or abort it
- refresh the flow: replace the stream of the flow with a new stream.
- Limit the number of streams.

Flow could be reused/restarted or resumed.

The maximum number of flows is limited by the connection flow control per implementation.

** Flow and stream mapping

  A flow can use one QUIC bidi stream.

  A flow can use one QUIC unidi stream or [TBD] a pair of QUIC unidi streams.

  Application messages are sent across the flow in an orderly and reliable manner.

** Flow ownership

The flow is owned by the endpoint which starts it.

The owner takes responsibility for the stream lifecycle, including startup, shutdown, restart after reconnect,
error recovery. This avoids race conditions or leaving unused streams.

** Flow ID

Each flow has a =FlowID=, the FlowID is picked by initiator.

The FlowID is unique within the MQTT session.

FlowID is a Variable-Length Integer.

The least significant bit of the FlowID identifies if it is a server flow to avoid FlowID collision between client and server.

** Flow Type

In order for MQTT to coexist with other protocols on the same QUIC connection,
MQTT-next uses defined (IANA) flow types to distinguish from the other protocols.

** Flow Header

The flow header is the first few bytes used by both endpoints to identify the flow and gather information for using the flow.

NOTE, the 'Variable-Length Integer Encoding' (i) in the flow header is defined in RFC 9000 and not the "Variable Byte Integer" in the MQTT specification.


Stream Header Formats:

*** Control Flow Stream header
#+begin_src
control_flow_header {
  Flow_type(i) = 0x11,
  Flow_id(i): 0x00,
  Flow_persistent_flag(8),
}
#+end_src

*** Client Data Flow Stream header
#+begin_src
client_data_flow_header {
  Flow_type(i) = 0x12,
  Flow_id(i),
  Flow_expire_interval(i),
  Flow_flags(8),
  [Flow_optional_headers]
}
#+end_src

*** Server Data Flow Stream header
#+begin_src
server_data_flow_header {
  Flow_type(i) = 0x13,
  Flow_id(i),
  Flow_expire_interval(i),
  Flow_flags(8),
  [Flow_optional_headers]
}
#+end_src

*** User defined Flow Stream header
#+begin_src
user_data_flow_header {
  Flow_type(i) = 0x14,
  Flow_id(i),
}
#+end_src

** Flow Expire Interval

** Flow Flags

#+begin_src

flow_flags {
  clean(1),
  abort_if_no_state(1),
  err_tolerance(2),
  persistent_qos(1),
  persistent_topic_alias(1),
  persistent_subscriptions(1),
  optional_headers(1),
}
#+end_src

clean:
  if it is a clean start of the flow, both endpoint MUST drop the states.

abort_if_no_state:
  If set and flow state is gone for any reason, peer MUST abort this flow with RC: ERROR_NO_FLOW_STATE
  It is protocol error level 1 if both this flag and clean flag are set.
  Local node could restart the flow with clean set to true afterwards.

persistent_qos:
  if set, both endpoints must persistent QoS states.

persistent_topic_alias:
  if set, both endpoints must persistent topic alias
  if unset, both endpoints must not persistent topic alias that topic alias mapping does not survives from a flow close.

persistent_subscriptions(1):
  if set, both endpoints must persistent topic id.
  It is protocol error level 1 if this flag is set in server flow

optional_headers(1):
  if set, optional_headers are set


** Flow start

Both client and server can initiate new flows.

The flow will survive disconnection or reconnection if the session and the flow are not expired (set by flow_expire_interval)

The acceptor which is the peer of the flow initiator must check if the flow header is valided and supported. If not, the stream
recv should be aborted with with the error code defined in *Error Code*.

Either side of the flow could abort the flow with ERROR_FLOW_OPEN_IDLE if the flow is idle after started.

Mismatch of initiator and flow type in control flow is protocol error level 0.

Mismatch initiator and flow type in data flow is protocol error level 1.

** Flow Termination (Close)

The flow termination could be triggered by either endpoint gracefully (clean) or aborting.

If graceful shutdown is triggered, it MAY end with abortive shutdown.

If abort is triggered, it MUST terminate with abortive shutdown.

Flow state MUST be removed from session state if gracefully terminated.

Flow state MUST NOT be removed from session state if it is aborted if the flow hasn't expired.

In the case of aborted termination, the sender MUST assume that the messages it has sent will be unhandled or handled, and for the receiver it is up to the implementation to decide how to deal with the received but unhandled data.


*** Flow graceful termination.

The flow owner must trigger the graceful shutdown of the flow by sending a QUIC STREAM FRAME with FIN flag.

The flow owner must finish sending a complete MQTT packet before starting the graceful shutdown procedure.

It is protocol error level 0 if the graceful shutdown of the flow is not initiated by the flow owner.

It is protocol error level 2 for data flow and protocol error level 0 for control flow if the sender terminates the flow with an incomplete MQTT packet.
 The recipient MUST reset the flow with APEC: ERROR_IMCOMPLETE_PACKET. (When FIN is set the recv size is known).

The graceful flow shutdown is completed ONLY when the other endpoint also terminates the stream by sending a QUIC STREAM FRAME with FIN flag set.

The receiver SHOULD ensure all received messages are processed before terminating the stream.


*** Flow abortive termination.

If the flow isn't terminated gracefully, it is abortive termination.

Abortive termination is triggered when at least one of the following events occurs

1. The sender aborts the transmission by sending a QUIC RESET_STREAM_FRAME.
2. Receiver aborts receive by sending a QUIC STOP_SENDING frame.
3. The sender receives the QUIC STOP_SENDING FRAME from the receiver.
4. Receiver receives QUIC RESET_STREAM FRAME from sender.
5. The connection is closed before the stream is properly terminated.

Note that for a bidi stream, the endpoint is both the sender and the receiver.


** Refresh flow stream

Flow stream refresh can only be triggered by the flow owner.

This is used to interrupt the data transfer in progress by the application.

For example, to discard the obsolete data being transferred, to update the persistent policy defined by setting new flow flags, or to recover from the application error, or to discard the flow state at the peer.

Flow takeover is done by refreshing the QUIC stream in use, where the new stream ID MUST be greater than the old stream ID. Greater streamid of the same QUIC stream type always takes precedence.

The flow refresh has the side effect that the owner aborts both sending and receiving of the old flow.
and the peer MUST unconditionally abort its send/recv.

The incomplete MQTT packet in the buffer at both ends MUST be discarded.

The stream owner must ensure that it has sufficient flow control credits before starting the takeover process.

As each endpoint manages it's own flow id spaces, the takeover could change the persistent flag of the flow.

** Flow Recover

Flow recover means that a previously aborted flow identified by flowid is reopened.

Flow recover happens in two cases:

1. restarting an aborted flow

2. Restart of a flow to which a connection has been re-established.

The owner of the flow is responsible for restarting the flow.

** Drop the Flow

If the flow owner wishes to discard the flow state at the peer, he can do so by setting the flow
with the flow flag clean_start set, all persistent flags unset and a STREAM FIN flag set.

This could be done by restarting a closed flow or by refreshing the stream on an existing flow.


** MQTT Packet and Flow mappings

|-------------+--------------+------------------+------------------+---------------------|
| MQTT Packet | Control flow | Client Data flow | Server Data Flow | Unreliable Datagram |
|-------------+--------------+------------------+------------------+---------------------|
| CONNECT     | YES          | NO               | NO               | NO                  |
| CONNACK     | YES          | NO               | NO               | NO                  |
| PUBLISH     | YES          | YES              | YES              | YES                 |
| PUBACK      | YES          | YES              | YES              | YES                 |
| PUBREC      | YES          | YES              | YES              | YES                 |
| PUBCOMP     | YES          | YES              | YES              | YES                 |
| PUBREL      | YES          | YES              | YES              | YES                 |
| SUBSCRIBE   | YES          | YES              | NO               | YES                 |
| SUBACK      | YES          | YES              | NO               | YES                 |
| UNSUBSCRIBE | YES          | YES              | NO               | YES                 |
| UNSUBACK    | YES          | YES              | NO               | YES                 |
| PINGREQ     | YES          | YES              | YES              | NO                  |
| PINGRESP    | YES          | YES              | YES              | NO                  |
| DISCONNECT  | YES          | NO               | NO               | NO                  |
| AUTH        | YES          | NO               | NO               | NO                  |
|-------------+--------------+------------------+------------------+---------------------|


** Table of Flow Types

|--------------------------------+------------+---------------+-------------------------------+---|
| MQTT Types (id.)               | dir        | initiate by   | Transport data                |   |
|--------------------------------+------------+---------------+-------------------------------+---|
| Control flow            (0x11) | bidi       | Client        | MQTT control packet           |   |
| Client flow             (0x12) | bidi/unidi | Client        | MQTT data packet              |   |
| Server flow             (0x13) | bidi/unidi | Server        | Server assigned subscriptions |   |
| User-Defined flow       (0x14) | bidi/unidi | Client/Server | Other protocol data           |   |
|--------------------------------+------------+---------------+-------------------------------+---|


Note, type `0x1f * N + 0x21` are reserved
Note, control packet and data packet are redefined here

Flow could only be recoverd by the same initiator.


** Flow State

The flow state is associated with the FlowId, the flow state persists from connection and stream close.

The flow state is used to persist the send state of the flow, which includes

- Flow type (ownership and usage)
- Subscription
- topic alias
- Delivery state of QoS > 0 messages sent.

Each endpoint of a flow maintains its own flow state as a minimum persistence:

*** Client side

- Delivery state of QoS >0 messages sent.
- topic alias

*** Server side

- Subscriptions and subscription ID
- Topic alias
- Delivery state of QoS >0 messages.
- buffered QoS >0 messages, QoS 0 optional.
- Flow Expiry Time

* Session

** Session State

The existence of the session.

Session State is associated with MQTT Client ID.

Session State contains the zero or many flow states.

Session state contains session expire interval.

Session State must be discarded when the connection is closed AND the session expire interval has passed.

If the session state is discarded, the flow states in the session are also discarded.

* Error Handlings

  MQTT-next is designed to be robust to application errors so that the connection could be maintained and the other application muxing the flow in the same connection are not affected by errors that are isolated.

  Errors do not necessarily mean logical errors or protocol violations. It could also mean the cancellation of operations such as
  aborting the transmission of a large payload, or cancelling a subscription that is no longer of interest as a shortcut to sending an unsubscribe.

  There are three levels of protocol error:

  * Protocol Error Levels

  1. Protocol error level 0

  This is a serious error that cannot be violated or the connection cannot be served by the broker.

  The connection MUST be closed.

  For other errors, it is up to the implementation whether to close the connection by notifying the peer or to close silently.

  2. Protocol error level 1

  The error is isolated in the specific flow, but the flow state MUST be discarded because it is impossible to maintain the state
  or the error could lead to inconsistent states.

  3. Protocol error level 2

  Not a serious error, most likely could be recovered with a retry or the error is isolated in the specific flow.

  The handling of protocol error level 2 could be negotiated between the two endpoints or decided by implementation.

  The flow state is maintained but the flow is aborted and a restart is required for recovery.

  The endpoints aborting the flow MUST abort the flow with a reason sent to the peer.

  The endpoint MAY gracefully shut down or abort another flow as a side effect of a protocol error level 2.

* Error Code

** Application Error Code on Connection

Error code used in the QUIC CONNECTION_CLOSE Frame

   |-------------------+------+--------------+--------------------------------------------------------|
   | Error Name        | Code | Reuse MQTT 5 | Meaning                                                |
   | NO_ERROR          | 0x00 |              |                                                        |
   | ERROR_TLS_ERROR   | 0xB1 |              | TLS handshake success but extra validations are failed |
   | ERROR_UNSPECIFIED | 0xB2 |              | Default UNSPECIFIED error                              |
   |                   |      |              |                                                        |
   |-------------------+------+--------------+--------------------------------------------------------|

** Application Error Code on Stream Flow

 Error code used in QUIC RESET_STREAM FRAME

   |-------------------------------+------+--------+---------------+-------------------------------------------------------------------------------------|
   | Error Name                    | Code | Packet | Discard State | Meaning                                                                             |
   | NO_ERROR                      | 0x00 |        | N             | NO ERROR                                                                            |
   | ERROR_NO_FLOW_STATE           | 0xB3 |        | N/A           | FLOW STATE does not exist                                                           |
   | NOT_FLOW_OWNER                | 0xB4 |        | N             | Only FLOW owner is allowed on this operation                                        |
   | ERROR_STREAM_TYPE             | 0xB5 |        | N             | Unsupported stream type                                                             |
   | ERROR_BAD_FLOW_ID             | 0xB6 |        | Y             | FlowID and FlowType missmatch                                                       |
   | ERROR_PERSISTENT_TOPIC        | 0xB7 |        | N             | Persistent topic alias unsupported                                                  |
   | ERROR_PERSISTENT_SUB          | 0xB8 |        | Y             | Persistent subscription unsupported                                                 |
   | ERROR_OPTIONAL_HEADER         | 0xB9 |        | Y             | Optional Headers unsupported                                                        |
   | ERROR_IMCOMPLETE_PACKET       | 0xBA |        | N             | Receiver abort graceful shutdown due to received incomplete packet.                 |
   | ERROR_FLOW_OPEN_IDLE          | 0xBB |        | N             | FLOW is idle, no data after opening                                                 |
   | ERROR_FLOW_CANCELLED          | 0xBC |        | Y             | FLOW operation is cancelled, also discard the flow                                  |
   | ERROR_FLOW_PACKET_CANCELLED   | 0xBD |        | N             | FLOW operation is cancelled                                                         |
   | ERROR_FLOW_REFUSED            | 0xBE |        | N             | FLOW is refused                                                                     |
   | ERROR_DISCARD_STATE           | 0xBF |        | Y             | The entire FLOW state is discarded (includes SUBSCRIPTION, QoS Delivery states ...) |
   | ERROR_SERVER_PUSH_NOT_WELCOME | 0XC0 |        | Y             | Server Push flow is not welcomed by the client                                      |
   |                               |      |        |               |                                                                                     |
   |-------------------------------+------+--------+---------------+-------------------------------------------------------------------------------------|

** Error Code in MQTT Packet

Refer to MQTT 5.0, 2.4 Reason Code.

This applies to the datagram as well.

* Limitations

  1. To resume a multistream session after fallback to TCP based transport needs extra work to reuse TCP connection
     for all the streams.
      
